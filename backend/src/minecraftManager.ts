import { ChildProcess, spawn, execSync } from 'child_process';
import path from 'path';
import fs from 'fs';
import https from 'https';
import http from 'http';
import { GameServer, MinecraftFlavor } from './types';

// ── Java Detection ─────────────────────────────────────
let detectedJavaPath: string | null = null;

export function detectJava(): string | null {
  if (detectedJavaPath) return detectedJavaPath;
  
  // Check env var first
  const envJava = process.env.JAVA_PATH;
  if (envJava && fs.existsSync(envJava)) {
    detectedJavaPath = envJava;
    return envJava;
  }

  // Try common paths on Windows
  const candidates = [
    'java',  // on PATH
    'C:\\Program Files\\Java\\jdk-21\\bin\\java.exe',
    'C:\\Program Files\\Java\\jdk-17\\bin\\java.exe',
    'C:\\Program Files\\Eclipse Adoptium\\jdk-21.0.4.7-hotspot\\bin\\java.exe',
    'C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.12.7-hotspot\\bin\\java.exe',
    'C:\\Program Files\\Microsoft\\jdk-17.0.12.7-hotspot\\bin\\java.exe',
    'C:\\Program Files\\Zulu\\zulu-21\\bin\\java.exe',
  ];

  for (const candidate of candidates) {
    try {
      const result = execSync(`"${candidate}" -version 2>&1`, { encoding: 'utf-8', timeout: 5000 });
      if (result.includes('version')) {
        detectedJavaPath = candidate;
        return candidate;
      }
    } catch {
      // try next
    }
  }

  return null;
}

export function getJavaVersion(): string | null {
  const java = detectJava();
  if (!java) return null;
  try {
    const result = execSync(`"${java}" -version 2>&1`, { encoding: 'utf-8', timeout: 5000 });
    const match = result.match(/version "([^"]+)"/);
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

export function isJavaInstalled(): boolean {
  return detectJava() !== null;
}

// ── server.properties generation ───────────────────────
export function generateServerProperties(server: GameServer): string {
  return `#Minecraft server properties
#Generated by SVNHost
server-port=${server.port}
server-name=${server.name}
motd=\\u00A7b${server.name} \\u00A77- SVNHost
max-players=${server.maxPlayers}
online-mode=true
enable-command-block=true
view-distance=10
simulation-distance=10
spawn-protection=0
difficulty=normal
gamemode=survival
level-name=world
level-seed=
pvp=true
white-list=false
enforce-whitelist=false
enable-query=true
query.port=${server.port}
enable-rcon=false
`;
}

// ── EULA ───────────────────────────────────────────────
export function writeEula(serverDir: string): void {
  fs.writeFileSync(path.join(serverDir, 'eula.txt'), 'eula=true\n', 'utf-8');
}

// ── Download MC Server JAR ─────────────────────────────

function httpGet(url: string): Promise<string> {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? https : http;
    client.get(url, (res) => {
      if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        return httpGet(res.headers.location).then(resolve).catch(reject);
      }
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => resolve(data));
      res.on('error', reject);
    }).on('error', reject);
  });
}

function httpDownload(url: string, dest: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? https : http;
    client.get(url, (res) => {
      if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        return httpDownload(res.headers.location, dest).then(resolve).catch(reject);
      }
      const file = fs.createWriteStream(dest);
      res.pipe(file);
      file.on('finish', () => { file.close(); resolve(); });
      file.on('error', reject);
    }).on('error', reject);
  });
}

export async function downloadMinecraftJar(
  serverDir: string,
  flavor: MinecraftFlavor = 'paper',
  version: string = 'latest',
): Promise<string> {
  const jarPath = path.join(serverDir, 'server.jar');

  // If jar already exists, skip
  if (fs.existsSync(jarPath)) return 'server.jar';

  if (flavor === 'paper') {
    return downloadPaperJar(serverDir, version);
  } else if (flavor === 'vanilla') {
    return downloadVanillaJar(serverDir, version);
  } else {
    // For spigot/forge/fabric — use paper as fallback since building spigot requires BuildTools
    return downloadPaperJar(serverDir, version);
  }
}

async function downloadPaperJar(serverDir: string, version: string): Promise<string> {
  try {
    // Get latest version from PaperMC API
    const versionsJson = await httpGet('https://api.papermc.io/v2/projects/paper');
    const versionsData = JSON.parse(versionsJson);
    
    let mcVersion = version;
    if (version === 'latest') {
      mcVersion = versionsData.versions[versionsData.versions.length - 1];
    }

    // Get builds for this version
    const buildsJson = await httpGet(`https://api.papermc.io/v2/projects/paper/versions/${mcVersion}`);
    const buildsData = JSON.parse(buildsJson);
    const latestBuild = buildsData.builds[buildsData.builds.length - 1];

    // Get download info
    const buildJson = await httpGet(`https://api.papermc.io/v2/projects/paper/versions/${mcVersion}/builds/${latestBuild}`);
    const buildData = JSON.parse(buildJson);
    const fileName = buildData.downloads.application.name;

    // Download
    const downloadUrl = `https://api.papermc.io/v2/projects/paper/versions/${mcVersion}/builds/${latestBuild}/downloads/${fileName}`;
    const dest = path.join(serverDir, 'server.jar');
    await httpDownload(downloadUrl, dest);
    
    return 'server.jar';
  } catch (err: any) {
    throw new Error(`Failed to download PaperMC: ${err.message}`);
  }
}

async function downloadVanillaJar(serverDir: string, version: string): Promise<string> {
  try {
    // Mojang version manifest
    const manifestJson = await httpGet('https://piston-meta.mojang.com/mc/game/version_manifest_v2.json');
    const manifest = JSON.parse(manifestJson);

    let versionInfo;
    if (version === 'latest') {
      const latestId = manifest.latest.release;
      versionInfo = manifest.versions.find((v: any) => v.id === latestId);
    } else {
      versionInfo = manifest.versions.find((v: any) => v.id === version);
    }

    if (!versionInfo) throw new Error(`Minecraft version ${version} not found`);

    // Get version details
    const versionJson = await httpGet(versionInfo.url);
    const versionData = JSON.parse(versionJson);
    const serverUrl = versionData.downloads.server.url;

    // Download
    const dest = path.join(serverDir, 'server.jar');
    await httpDownload(serverUrl, dest);

    return 'server.jar';
  } catch (err: any) {
    throw new Error(`Failed to download Vanilla MC: ${err.message}`);
  }
}

// ── Spawn Minecraft Server Process ─────────────────────
export function spawnMinecraftProcess(
  server: GameServer,
  serverDir: string,
): ChildProcess {
  const javaPath = server.javaPath || detectJava() || 'java';
  const ramMb = server.ramMb || 2048;
  const jarFile = server.mcJarFile || 'server.jar';

  const args = [
    `-Xmx${ramMb}M`,
    `-Xms${Math.floor(ramMb / 2)}M`,
    '-jar', jarFile,
    'nogui',
  ];

  // Add Paper-specific optimizations
  if (server.mcFlavor === 'paper') {
    args.splice(1, 0,
      '-XX:+UseG1GC',
      '-XX:+ParallelRefProcEnabled',
      '-XX:MaxGCPauseMillis=200',
      '-XX:+UnlockExperimentalVMOptions',
      '-XX:+DisableExplicitGC',
      '-XX:G1NewSizePercent=30',
      '-XX:G1MaxNewSizePercent=40',
      '-XX:G1HeapRegionSize=8M',
    );
  }

  const child = spawn(javaPath, args, {
    cwd: serverDir,
    env: { ...process.env },
    stdio: ['pipe', 'pipe', 'pipe'],
  });

  return child;
}
